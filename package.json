{
  "type": "module",
  "dependencies": {
    "express": "^4.19.2",
    "multer": "^1.4.5-lts.1",
    "fluent-ffmpeg": "^2.1.2",
    "ffmpeg-static": "^5.2.0"
  }
}

import os from "node:os";
import path from "node:path";

app.post("/concat", upload.any(), async (req, res) => {
  try {
    const files = (req.files || []).sort((a, b) => {
      // expect names clip0, clip1, ...
      const ai = Number((a.fieldname || "").replace("clip", ""));
      const bi = Number((b.fieldname || "").replace("clip", ""));
      return ai - bi;
    });

    if (!files.length) return res.status(400).json({ error: "Upload files named clip0..clipN" });

    // Create ffmpeg concat list
    const listPath = path.join(os.tmpdir(), `concat-${Date.now()}.txt`);
    const out = path.join(os.tmpdir(), `final-${Date.now()}.mp3`);

    const txt = files.map(f => `file '${f.path.replace(/'/g, "'\\''")}'`).join("\n");
    await fsp.writeFile(listPath, txt, "utf8");

    await new Promise((resolve, reject) => {
      ffmpeg()
        .input(listPath)
        .inputOptions(["-f concat", "-safe 0"])
        .outputOptions(["-c:a libmp3lame", "-q:a 2"])
        .on("error", reject)
        .on("end", resolve)
        .save(out);
    });

    const buf = await fsp.readFile(out);
    res.setHeader("Content-Type", "audio/mpeg");
    res.setHeader("Content-Length", buf.length);
    res.send(buf);

    // cleanup best-effort
    try { fs.unlinkSync(listPath); } catch {}
    files.forEach(f => { try { fs.unlinkSync(f.path); } catch {} });
    try { fs.unlinkSync(out); } catch {}
  } catch (e) {
    res.status(500).json({ error: e?.message || String(e) });
  }
});
